import{_ as t,r as e,o,c,a as n,b as a,d as p,e as l}from"./app-CtA61ec0.js";const i={},u=l(`<h1 id="函数式编程" tabindex="-1"><a class="header-anchor" href="#函数式编程"><span>函数式编程</span></a></h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h2><p>函数式编程（英语：functional programming），又称泛函编程，是一种编程范式，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。</p><h2 id="一些概念" tabindex="-1"><a class="header-anchor" href="#一些概念"><span>一些概念</span></a></h2><h3 id="纯函数" tabindex="-1"><a class="header-anchor" href="#纯函数"><span>纯函数</span></a></h3><p>纯函数是函数式编程的基石，无副作用的函数</p><ul><li>函数在相同的输入值时，总是产生相同的输出。函数的输出和当前运行环境的上下文状态无关。</li><li>函数运行过程不影响运行环境，也就是无副作用（如触发事件、发起 http 请求、打印/log 等）</li></ul><p>简单来说，也就是当一个函数的输出不受外部环境影响，同时也不影响外部环境时，该函数就是纯函数，也就是它只关注逻辑运算和数学运算，同一个输入总得到同一个输出。javascript 内置函数有不少纯函数，也有不少非纯函数。</p><p>纯函数：<code>Array.prototype.slice</code>，<code>Array.prototype.map</code>，<code>String.prototype.toUpperCase</code></p><p>非纯函数：<code>Math.random</code>，<code>Date.now</code>，<code>Array.ptototype.splice</code></p><p>纯函数在可缓存性、可移植性、可测试性以及并行计算方面都有着巨大的优势：</p><ul><li>可以进行缓存。我们就可以采用动态规划的方法保存中间值，用来代替实际函数的执行结果，大大提升效率。</li><li>可以进行高并发。因为不依赖于环境，可以调度到另一个线程、worker 甚至其它机器上，反正也没有环境依赖。</li><li>容易测试，容易证明正确性。不容易产生偶现问题，也跟环境无关，非常利于测试。</li></ul><h3 id="函数柯里化" tabindex="-1"><a class="header-anchor" href="#函数柯里化"><span>函数柯里化</span></a></h3><p>将一个低阶函数转换为高阶函数的过程就叫柯里化。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//es5写法</span>
<span class="token keyword">var</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//es6写法</span>
<span class="token keyword">var</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>

<span class="token comment">//试试看</span>
<span class="token keyword">var</span> increment <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> addTen <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">increment</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>

<span class="token function">addTen</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 12</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数柯里化是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存。</p><h3 id="声明式和命令式代码" tabindex="-1"><a class="header-anchor" href="#声明式和命令式代码"><span>声明式和命令式代码</span></a></h3><p><strong>命令式代码</strong>：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。</p><p><strong>声明式代码</strong>：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 命令式</span>
<span class="token keyword">var</span> makes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  makes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>make<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 声明式</span>
<span class="token keyword">var</span> makes <span class="token operator">=</span> cars<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">car</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> car<span class="token punctuation">.</span>make<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器</p><p>声明式的写法是一个表达式，如何进行计数器迭代，返回的数组如何收集，这些细节都隐藏了起来。它指明的是做什么，而不是怎么做，更加清晰和简洁。</p><p>函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。</p><p>相反，不纯的不函数式的代码会产生副作用或者依赖外部系统环境，使用它们的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。</p><h3 id="偏函数和高阶函数" tabindex="-1"><a class="header-anchor" href="#偏函数和高阶函数"><span>偏函数和高阶函数</span></a></h3><p>函数式编程与命令行编程体感上的最大区别：</p><ul><li><p>函数是一等公式，我们应该熟悉变量中保存函数再对其进行调用</p></li><li><p>函数可以出现在返回值里，最重要的用法就是把输入是 n(n&gt;2)个参数的函数转换成 n 个 1 个参数的串联调用，这就是传说中的柯里化。这种减少了参数的新函数，我们称之为<strong>偏函数</strong></p></li><li><p>函数可以用做函数的参数，这样的函数称为<strong>高阶函数</strong></p></li></ul><h2 id="使用方式" tabindex="-1"><a class="header-anchor" href="#使用方式"><span>使用方式</span></a></h2><h3 id="函数组合" tabindex="-1"><a class="header-anchor" href="#函数组合"><span>函数组合</span></a></h3><p>当我们需要对数据做一系列操作时，往往使用嵌套调用函数的方式</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> shut <span class="token operator">=</span> <span class="token function">exclaim</span><span class="token punctuation">(</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样代码是由内往外执行，不直观，我们希望代码从右往左执行，这个时候我们就得使用组合。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//定义compose</span>
<span class="token keyword">var</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span>
  <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    args<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">item</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">toUpperCase</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">exclaim</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> shout <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>exclaim<span class="token punctuation">,</span> toUpperCase<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">shout</span><span class="token punctuation">(</span><span class="token string">&quot;send in the clowns&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//=&gt; &quot;SEND IN THE CLOWNS!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码从右往左执行，非常清晰明了，一目了然。我们定义的 compose 像 N 面胶一样，可以将任意多个纯函数结合到一起。这种灵活的组合可以让我们像拼积木一样来组合函数式的代码</p><h3 id="用容器封装函数能力" tabindex="-1"><a class="header-anchor" href="#用容器封装函数能力"><span>用容器封装函数能力</span></a></h3><p>当我们需要重用一个函数时，我们可以用面向对象的思维将函数封装到一个类中：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MayBeNumber</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MayBeNumber</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token function">isNum</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们不管拿到一个什么对象，用其构造一个 MayBeNumber 对象出来，再调用这个对象的 map 方法去调用数学函数，就自带了 isNum 的能力。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> num1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MayBeNumber</span><span class="token punctuation">(</span><span class="token number">3.3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>sqr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> notnum1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MayBeNumber</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>sqr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>封装到对象中的另一个好处是我们可以用&quot;.&quot;多次调用了，比如我们想调两次算 4 次方，只要在.map(sqr2)之后再来一个.map(sqr2)</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> num3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MayBeNumber</span><span class="token punctuation">(</span><span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>sqr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>sqr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用对象封装之后的另一个好处是，函数嵌套调用跟命令式是相反的顺序，而用 map 则与命令式一致。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//old</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sqr2</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//now</span>
<span class="token keyword">let</span> num4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MayBeNumber</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>sin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>sqr2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>封装到对象中，看起来还不错，但是函数式编程还搞出来 new 对象再 map，为什么不能构造对象时也用个函数呢？这好办，我们给它定义个 of 方法吧：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>MayBeNumber<span class="token punctuation">.</span><span class="token function-variable function">of</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MayBeNumber</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来总结下前面这种容器的设计模式：</p><ul><li><p>有一个用于存储值的容器</p></li><li><p>这个容器提供一个 map 函数，作用是 map 函数使其调用的函数可以跟容器中的值进行计算，最终返回的还是容器的对象</p></li></ul><p>我们可以把这个设计模式叫做 <strong>Functor 函子</strong>。</p><p>如果这个容器还提供一个 of 函数将值转换成容器，那么它叫做 <strong>Pointed Functor</strong>.</p><p>比如我们看下 js 中的 Array 类型：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> aa1 <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aa1<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aa1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>sin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它支持 of 函数，它还支持 map 函数调用 Math.sin 对 Array 中的值进行计算，map 的结果仍然是一个 Array。</p><p>那么我们可以说，Array 是一个 Pointed Functor.</p><h3 id="一次有效的函数" tabindex="-1"><a class="header-anchor" href="#一次有效的函数"><span>一次有效的函数</span></a></h3><p>如何用函数式方法实现一个只执行一次有效的函数？用闭包。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">once</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> done <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> init_data <span class="token operator">=</span> <span class="token function">once</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Initialize data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">init_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">init_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><ul><li><p>函数式编程的核心概念很简单，就是将函数存到变量里，用在参数里，用在返回值里</p></li><li><p>在编程时要时刻记住将无副作用与有副作用代码分开</p></li><li><p>函数式编程的原理虽然很简单，但是因为大家习惯了命令式编程，刚开始学习时会有诸多不习惯，用多了就好了</p></li><li><p>函数式编程背后有其数学基础，在学习时可以先不要管它，当成设计模式学习。等将来熟悉之后，还是建议去了解下背后的真正原理</p></li></ul>`,58),r=n("p",null,"参考链接",-1),k={href:"https://mp.weixin.qq.com/s/_4xCDS3uJNsBScWMtnfMOA",target:"_blank",rel:"noopener noreferrer"},d={href:"https://mp.weixin.qq.com/s/32DwoU2OtAcYPpTQAo6npA",target:"_blank",rel:"noopener noreferrer"};function v(m,b){const s=e("ExternalLinkIcon");return o(),c("div",null,[u,n("blockquote",null,[r,n("p",null,[n("a",k,[a("前端开发函数式编程入门"),p(s)])]),n("p",null,[n("a",d,[a("javascript 函数式编程基础"),p(s)])])])])}const g=t(i,[["render",v],["__file","functional-programming.html.vue"]]),f=JSON.parse('{"path":"/development-practice/functional-programming.html","title":"函数式编程","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"一些概念","slug":"一些概念","link":"#一些概念","children":[{"level":3,"title":"纯函数","slug":"纯函数","link":"#纯函数","children":[]},{"level":3,"title":"函数柯里化","slug":"函数柯里化","link":"#函数柯里化","children":[]},{"level":3,"title":"声明式和命令式代码","slug":"声明式和命令式代码","link":"#声明式和命令式代码","children":[]},{"level":3,"title":"偏函数和高阶函数","slug":"偏函数和高阶函数","link":"#偏函数和高阶函数","children":[]}]},{"level":2,"title":"使用方式","slug":"使用方式","link":"#使用方式","children":[{"level":3,"title":"函数组合","slug":"函数组合","link":"#函数组合","children":[]},{"level":3,"title":"用容器封装函数能力","slug":"用容器封装函数能力","link":"#用容器封装函数能力","children":[]},{"level":3,"title":"一次有效的函数","slug":"一次有效的函数","link":"#一次有效的函数","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"updatedTime":1708503944000,"contributors":[{"name":"guokc","email":"guokc@tsintergy.com","commits":1}]},"filePathRelative":"development-practice/functional-programming.md"}');export{g as comp,f as data};
