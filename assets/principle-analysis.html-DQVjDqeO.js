import{_ as l,r as p,o,c as i,a,b as n,d as e,e as t}from"./app-ZrMgA43q.js";const c="/my-notes/assets/任务队列-BstND6gz.png",r={},u=t('<h1 id="原理分析" tabindex="-1"><a class="header-anchor" href="#原理分析"><span>原理分析</span></a></h1><h2 id="js-执行机制" tabindex="-1"><a class="header-anchor" href="#js-执行机制"><span>JS 执行机制</span></a></h2><h3 id="单线程" tabindex="-1"><a class="header-anchor" href="#单线程"><span>单线程</span></a></h3><p>js 运作在浏览器中是单线程的，即 js 代码始终在一个线程上执行，js 同时只能执行一个任务，其它的任务则会排队等待执行。但更确切的说 JS 只有一个主线程，其实他还有一些其他线程的，当然所有函数任务只可以在主线程执行。</p><p>JS 作为浏览器的脚本，其最根本的作用就是实现用户与浏览器的交互行为，当一个用户要删除一个 A，又同时向 A 中添加内容的时候，若是多线程，应该怎么样去处理？没有办法处理，若是单线程就很简单了，用户先执行那个操作，我们主线程就进行哪一个，不会出现任何冲突！</p><h3 id="异步" tabindex="-1"><a class="header-anchor" href="#异步"><span>异步</span></a></h3><p>JS 明明单线程，但又同时可进行异步操作，这两者不是完全相反的嘛？</p><p>没错，JS 是单线程，但是 JS 是在浏览器中运行的脚本语言，它的宿主，浏览器可不是单线程的，除了主线程，它还有：</p><ul><li>UI 渲染线程</li><li>浏览器事件触发线程</li><li>http 请求线程</li><li>EventLoop 轮询的处理线程 ……</li></ul><p>这些线程的作用：</p><ul><li><strong>UI 线程</strong>用于渲染页面</li><li><strong>js 线程</strong>用于执行 js 任务</li><li><strong>浏览器事件触发线程</strong>用于控制交互，响应用户</li><li><strong>http 线程</strong>用于处理请求，ajax 是委托给浏览器新开一个 http 线程</li><li><strong>EventLoop 处理线程</strong>用于轮询消息队列</li></ul><h4 id="任务队列" tabindex="-1"><a class="header-anchor" href="#任务队列"><span>任务队列</span></a></h4><p>单线程只有前一个任务结束，才能执行下一个任务。如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JS 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是呢，任务就被分成两种，一种是<strong>同步任务</strong>，一种是<strong>异步任务</strong>。</p><p><strong>同步任务</strong>：只有前一个任务执行完成后，才可执行下一个任务，在主线程中形成一个执行栈，执行栈可以实现函数的层层调用。</p><p><strong>异步任务</strong>：这个队列的所有任务都是不进入主线程执行，而是被浏览提供的线程执行，当执行完毕后就会产生一个回调函数，并且通知主线程，在主线程执行完当前所执行的任务后，就会调取最早通知自己的回调函数，使其进入主线程中执行，比如 ajax 请求，再主线程中呈现的就是请求结果。 <img src="'+c+'" alt=""></p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件（回调函数 callback）。</li><li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。 “任务队列”是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</li></ul><p>“任务队列”中的事件，除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p><p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。因为存在<code>setTimeout</code>等定时函数，这类事件产生的消息进入到消息队列，被执行的时机取决与它在队列中的位置和执行时间有关。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。</p><h2 id="v8-垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#v8-垃圾回收机制"><span>V8 垃圾回收机制</span></a></h2>',22),d={href:"https://mp.weixin.qq.com/s/VbAUPGt3sUVzEQHxWYmlBw",target:"_blank",rel:"noopener noreferrer"},h=t(`<h2 id="v8-引擎下的-数组-底层实现" tabindex="-1"><a class="header-anchor" href="#v8-引擎下的-数组-底层实现"><span>V8 引擎下的“数组”底层实现</span></a></h2><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h3><p>C、C++、Java、Scala 等语言中数组的实现，是通过在内存中划分一串<strong>连续的、固定长度</strong>的空间，来实现存放一组有限个<strong>相同数据类型</strong>的数据结构。JS 的数组可以存放不同类型的元素、并且数组长度是可变的。</p><h3 id="js-数组的实现" tabindex="-1"><a class="header-anchor" href="#js-数组的实现"><span>JS 数组的实现</span></a></h3><p>在 JS 中数组被实现为特殊的对象，底层就是个 Map ，key 为 0，1，2，3 这种索引，value 就是数组的元素。</p><p>V8 中对数组做了一层封装，使其有两种实现方式：<strong>快数组和慢数组</strong>，快数组底层是连续内存，通过索引直接定位，慢数组底层是哈希表，通过计算哈希值来定位。两种实现方式各有特点，有各自的使用情况，也会相互转换。</p><ul><li><p>快数组：快速的后备存储结构是 FixedArray ，并且数组长度 &lt;= elements.length();</p></li><li><p>慢数组：缓慢的后备存储结构是一个以数字为键的 HashTable 。</p></li></ul><blockquote><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p></blockquote><h4 id="快数组-fast-elements" tabindex="-1"><a class="header-anchor" href="#快数组-fast-elements"><span>快数组（FAST ELEMENTS）</span></a></h4><p>新创建的空数组，默认的存储方式是快数组，快数组是一种线性的存储方式，长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现</p><p>扩容的计算方式：<code>new_capacity = old_capacity /2 + old_capacity + 16</code>，也就是，扩容后的新容量 = 旧容量的 1.5 倍 + 16，扩容后会将数组拷贝到新的内存空间中</p><p>收缩的计算方式：如果<code>容量 &gt;= length的2倍 + 16</code>，则进行收缩容量调整，否则用 holes 对象填充未被初始化的位置。</p><blockquote><p>holes （空洞）对象指的是数组中分配了空间，但是没有存放元素的位置。</p></blockquote><p><strong>Fast Elements 和 Fast Holey Elements</strong></p><p>Fast Elements 模式中有一个扩展，是 Fast Holey Elements 模式，Fast Holey Elements 模式与 Fast Elements 模式一样，会动态分配连续的存储空间，分配空间的大小由最大的索引值决定。</p><p>新建数组时，如果没有设置容量，V8 会默认使用 Fast Elements 模式实现，如<code>let a = new Array(1,2,3)</code></p><p>对数组设置容量，但并没有进行内部元素的初始化，这样的话数组内部就存在了空洞，就会以 Fast Holey Elements 模式实现。例如<code>let a = new Array(10)</code>。 Fast Holey Elements 模式适合于数组中的 holes （空洞）情况，即只有某些索引存有数据，而其他的索引都没有赋值的情况。</p><h4 id="慢数组-dictionary-elements" tabindex="-1"><a class="header-anchor" href="#慢数组-dictionary-elements"><span>慢数组（DICTIONARY ELEMENTS）</span></a></h4><p>慢数组是一种字典的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，<strong>其效率会比快数组低</strong></p><h3 id="快数组、慢数组的区别" tabindex="-1"><a class="header-anchor" href="#快数组、慢数组的区别"><span>快数组、慢数组的区别</span></a></h3><ul><li>存储：快数组内存中是连续的，慢数组在内存中是零散分配的。</li><li>内存：由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还可能有很多空洞，是比较费内存的。慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。</li><li>遍历效率：快数组由于是空间连续的，遍历速度很快，而慢数组每次都要寻找 key 的位置，遍历效率会差一些。</li></ul><h3 id="快数组慢数组之间的转换" tabindex="-1"><a class="header-anchor" href="#快数组慢数组之间的转换"><span>快数组慢数组之间的转换</span></a></h3><h4 id="快-慢" tabindex="-1"><a class="header-anchor" href="#快-慢"><span>快 -&gt; 慢</span></a></h4><p>当出现以下情况时快数组会转换为慢数组</p><ul><li>新容量 &gt;= 3 _ 扩容后的容量 _ 2</li><li>当加入的 index- 当前 capacity &gt;= kMaxGap（1024） 时（也就是至少有了 1024 个空洞）</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 第二种情况示例</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">1030</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="慢-快" tabindex="-1"><a class="header-anchor" href="#慢-快"><span>慢 -&gt; 快</span></a></h4><p>处于哈希表实现的数组，在每次空间增长时， V8 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。</p><p>当慢数组的元素可存放在快数组中且长度在 smi（smi 在 64 位平台为-2^31 到 2^31 -1,32 位平台为-2^30 到 2^30 - 1） 之间且仅节省了 50%的空间（<code>2*dictionary_size&gt;=new_capacity</code>）,则会转变为快数组</p><p>现在往数组中添加值来填补空洞，往 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，数组会变成快数组的 Fast Holey Elements 模式</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">1030</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1030</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。</li><li>慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。</li></ul><h3 id="arraybuffer" tabindex="-1"><a class="header-anchor" href="#arraybuffer"><span>ArrayBuffer</span></a></h3><p>JS 在 ES6 也推出了可以按照需要分配连续内存的数组，这就是 ArrayBuffer。ArrayBuffer 会从内存中申请设定的二进制大小的空间</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这行代码就申请了 1kb 的内存区域。但是并不能对 arrayBuffer 直接操作，需要将它赋给一个视图来操作内存。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建了有符号的32位的整数数组，每个数占 4 字节，长度也就是 1024 / 4 = 256 个</span>
<span class="token keyword">let</span> intArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Int32Array</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Int32Array(256)[0,0,0,0,0,0,...]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,37),k={href:"https://zhuanlan.zhihu.com/p/96959371",target:"_blank",rel:"noopener noreferrer"};function m(v,b){const s=p("ExternalLinkIcon");return o(),i("div",null,[u,a("blockquote",null,[a("p",null,[n("参考链接 "),a("a",d,[n("13 张图！20 分钟！认识 V8 垃圾回收机制"),e(s)])])]),h,a("blockquote",null,[a("p",null,[n("参考链接： "),a("a",k,[n("探究 JS V8 引擎下的“数组”底层实现"),e(s)])])])])}const f=l(r,[["render",m],["__file","principle-analysis.html.vue"]]),y=JSON.parse('{"path":"/js/principle-analysis.html","title":"原理分析","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"JS 执行机制","slug":"js-执行机制","link":"#js-执行机制","children":[{"level":3,"title":"单线程","slug":"单线程","link":"#单线程","children":[]},{"level":3,"title":"异步","slug":"异步","link":"#异步","children":[]}]},{"level":2,"title":"V8 垃圾回收机制","slug":"v8-垃圾回收机制","link":"#v8-垃圾回收机制","children":[]},{"level":2,"title":"V8 引擎下的“数组”底层实现","slug":"v8-引擎下的-数组-底层实现","link":"#v8-引擎下的-数组-底层实现","children":[{"level":3,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":3,"title":"JS 数组的实现","slug":"js-数组的实现","link":"#js-数组的实现","children":[]},{"level":3,"title":"快数组、慢数组的区别","slug":"快数组、慢数组的区别","link":"#快数组、慢数组的区别","children":[]},{"level":3,"title":"快数组慢数组之间的转换","slug":"快数组慢数组之间的转换","link":"#快数组慢数组之间的转换","children":[]},{"level":3,"title":"ArrayBuffer","slug":"arraybuffer","link":"#arraybuffer","children":[]}]}],"git":{"updatedTime":1708502740000,"contributors":[{"name":"guokc","email":"guokc@tsintergy.com","commits":1}]},"filePathRelative":"js/principle-analysis.md"}');export{f as comp,y as data};
