"use strict";(self.webpackChunkmy_notes=self.webpackChunkmy_notes||[]).push([[594],{5509:(e,t,r)=>{r.r(t),r.d(t,{data:()=>a});const a={key:"v-400d76ab",path:"/git/reset-and-revert.html",title:"git reset 和 git revert 的区别",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"git reset",slug:"git-reset",children:[{level:3,title:"--hard",slug:"hard",children:[]},{level:3,title:"--soft",slug:"soft",children:[]},{level:3,title:"--mixed",slug:"mixed",children:[]},{level:3,title:"总结",slug:"总结",children:[]},{level:3,title:"使用场景",slug:"使用场景",children:[]}]},{level:2,title:"git revert",slug:"git-revert",children:[]},{level:2,title:"区别",slug:"区别",children:[]}],filePathRelative:"git/reset-and-revert.md",git:{updatedTime:1636989251e3,contributors:[]}}},6914:(e,t,r)=>{r.r(t),r.d(t,{default:()=>l});var a=r(6252);const s=(0,a.uE)('<h1 id="git-reset-和-git-revert-的区别" tabindex="-1"><a class="header-anchor" href="#git-reset-和-git-revert-的区别" aria-hidden="true">#</a> git reset 和 git revert 的区别</h1><h2 id="git-reset" tabindex="-1"><a class="header-anchor" href="#git-reset" aria-hidden="true">#</a> git reset</h2><p>reset 用于回退版本，有三种模式，soft、mixed、hard <img src="https://upload-images.jianshu.io/upload_images/4428238-fcad08ebe26933a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp" alt=""></p><h3 id="hard" tabindex="-1"><a class="header-anchor" href="#hard" aria-hidden="true">#</a> --hard</h3><p><strong>重置 stage 区和工作目录</strong></p><p><code>reset --hard</code> 会在重置 HEAD 和 branch 的同时，重置 stage 区和工作目录里的内容。当你在 reset 后面加了 --hard 参数时，你的 stage 区和工作目录里的内容会被完全重置为和 HEAD 的新位置相同的内容。换句话说，就是你的没有 commit 的修改会被全部擦掉。</p><h3 id="soft" tabindex="-1"><a class="header-anchor" href="#soft" aria-hidden="true">#</a> --soft</h3><p><strong>保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区</strong></p><p><code>reset --soft</code> 会在重置 HEAD 和 branch 时，保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区。</p><h3 id="mixed" tabindex="-1"><a class="header-anchor" href="#mixed" aria-hidden="true">#</a> --mixed</h3><p><strong>保留工作目录，并清空暂存区</strong></p><p><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code> 参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> reset --<span class="token operator">&lt;</span>参数<span class="token operator">&gt;</span> HEAD^ //回退到上一个提交\n<span class="token function">git</span> reset --<span class="token operator">&lt;</span>参数<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span> //回退到指定提交\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>实质上，<code>reset</code> 这个指令虽然可以用来撤销 commit ，但它的实质行为并不是撤销，而是移动 HEAD ，并且「捎带」上 HEAD 所指向的 branch（如果有的话）。</p><p>而<code>reset --hard HEAD^</code>之所以起到了撤销 commit 的效果，是因为它把 HEAD 和它所指向的 branch 一起移动到了当前 commit 的父 commit 上，从而起到了「撤销」的效果：</p><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h3><ul><li><strong>--hard</strong>：要放弃目前本地的所有改变,抛弃目标节点后的所有 commit</li><li><strong>--soft</strong>：想合并「当前节点」与「reset 目标节点」之间不具太大意义的 commit 记录，假如你需要把频繁提交的 commit 整合成一个 commit 的时候</li><li><strong>--mixed（默认）</strong>：与--soft 类似，再次提交多了 git add 添加到暂存区的操作</li></ul><h2 id="git-revert" tabindex="-1"><a class="header-anchor" href="#git-revert" aria-hidden="true">#</a> git revert</h2><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> revert <span class="token operator">&lt;</span>commit_id<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h2><ul><li><code>git revert</code> 是用一次新的 commit 来回滚之前的 commit，<code>git reset</code> 是直接删除指定的 commit</li><li><code>git reset</code> 是把 HEAD 向后移动了一下，而 <code>git revert</code> 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容</li><li>在回滚这一操作上看，效果差不多。<strong>但是在日后继续 merge 以前的老版本时有区别</strong><ul><li><code>git revert</code> 是用一次逆向的 commit“中和”之前的提交，因此日后合并老的 branch 时，之前提交合并的代码仍然存在，导致不能够重新合并</li><li><code>git reset</code> 是之间把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的 commit 应该还会被引入</li></ul></li></ul><p><strong>参考文章：</strong></p>',24),i={href:"https://www.jianshu.com/p/c2ec5f06cf1a",target:"_blank",rel:"noopener noreferrer"},n=(0,a.Uk)("Git Reset 三种模式"),o={href:"https://mp.weixin.qq.com/s/Z3kLQz67omQdT8GA5LsC7g",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("面试官：说说你对 git reset 和 git revert 的理解？区别？"),l={render:function(e,t){const r=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[s,(0,a._)("p",null,[(0,a._)("a",i,[n,(0,a.Wm)(r)])]),(0,a._)("p",null,[(0,a._)("a",o,[d,(0,a.Wm)(r)])])],64)}}}}]);