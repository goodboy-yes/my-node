"use strict";(self.webpackChunkmy_notes=self.webpackChunkmy_notes||[]).push([[785],{6938:(n,a,l)=>{l.r(a),l.d(a,{data:()=>e});const e={key:"v-377d0bdf",path:"/js/principle-analysis.html",title:"原理分析",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"JS 执行机制",slug:"js-执行机制",children:[{level:3,title:"单线程",slug:"单线程",children:[]},{level:3,title:"异步",slug:"异步",children:[]}]},{level:2,title:"V8 垃圾回收机制",slug:"v8-垃圾回收机制",children:[]},{level:2,title:"V8 引擎下的“数组”底层实现",slug:"v8-引擎下的-数组-底层实现",children:[{level:3,title:"背景",slug:"背景",children:[]},{level:3,title:"JS 数组的实现",slug:"js-数组的实现",children:[]},{level:3,title:"快数组、慢数组的区别",slug:"快数组、慢数组的区别",children:[]},{level:3,title:"快数组慢数组之间的转换",slug:"快数组慢数组之间的转换",children:[]},{level:3,title:"ArrayBuffer",slug:"arraybuffer",children:[]}]}],filePathRelative:"js/principle-analysis.md",git:{updatedTime:1636038838e3,contributors:[]}}},2055:(n,a,l)=>{l.r(a),l.d(a,{default:()=>bn});var e=l(6252),s=l(6862);const t=(0,e._)("h1",{id:"原理分析",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#原理分析","aria-hidden":"true"},"#"),(0,e.Uk)(" 原理分析")],-1),r=(0,e._)("h2",{id:"js-执行机制",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#js-执行机制","aria-hidden":"true"},"#"),(0,e.Uk)(" JS 执行机制")],-1),u=(0,e._)("h3",{id:"单线程",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#单线程","aria-hidden":"true"},"#"),(0,e.Uk)(" 单线程")],-1),_=(0,e._)("p",null,"js 运作在浏览器中是单线程的，即 js 代码始终在一个线程上执行，js 同时只能执行一个任务，其它的任务则会排队等待执行。但更确切的说 JS 只有一个主线程，其实他还有一些其他线程的，当然所有函数任务只可以在主线程执行。",-1),c=(0,e._)("p",null,"JS 作为浏览器的脚本，其最根本的作用就是实现用户与浏览器的交互行为，当一个用户要删除一个 A，又同时向 A 中添加内容的时候，若是多线程，应该怎么样去处理？没有办法处理，若是单线程就很简单了，用户先执行那个操作，我们主线程就进行哪一个，不会出现任何冲突！",-1),o=(0,e._)("h3",{id:"异步",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#异步","aria-hidden":"true"},"#"),(0,e.Uk)(" 异步")],-1),i=(0,e._)("p",null,"JS 明明单线程，但又同时可进行异步操作，这两者不是完全相反的嘛？",-1),p=(0,e._)("p",null,"没错，JS 是单线程，但是 JS 是在浏览器中运行的脚本语言，它的宿主，浏览器可不是单线程的，除了主线程，它还有：",-1),k=(0,e._)("ul",null,[(0,e._)("li",null,"UI 渲染线程"),(0,e._)("li",null,"浏览器事件触发线程"),(0,e._)("li",null,"http 请求线程"),(0,e._)("li",null,"EventLoop 轮询的处理线程 ……")],-1),d=(0,e._)("p",null,"这些线程的作用：",-1),h=(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("strong",null,"UI 线程"),(0,e.Uk)("用于渲染页面")]),(0,e._)("li",null,[(0,e._)("strong",null,"js 线程"),(0,e.Uk)("用于执行 js 任务")]),(0,e._)("li",null,[(0,e._)("strong",null,"浏览器事件触发线程"),(0,e.Uk)("用于控制交互，响应用户")]),(0,e._)("li",null,[(0,e._)("strong",null,"http 线程"),(0,e.Uk)("用于处理请求，ajax 是委托给浏览器新开一个 http 线程")]),(0,e._)("li",null,[(0,e._)("strong",null,"EventLoop 处理线程"),(0,e.Uk)("用于轮询消息队列")])],-1),U=(0,e._)("h4",{id:"任务队列",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#任务队列","aria-hidden":"true"},"#"),(0,e.Uk)(" 任务队列")],-1),b=(0,e._)("p",null,"单线程只有前一个任务结束，才能执行下一个任务。如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。",-1),m=(0,e._)("p",null,"JS 语言的设计者意识到，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。",-1),f=(0,e._)("p",null,[(0,e.Uk)("于是呢，任务就被分成两种，一种是"),(0,e._)("strong",null,"同步任务"),(0,e.Uk)("，一种是"),(0,e._)("strong",null,"异步任务"),(0,e.Uk)("。")],-1),g=(0,e._)("p",null,[(0,e._)("strong",null,"同步任务"),(0,e.Uk)("：只有前一个任务执行完成后，才可执行下一个任务，在主线程中形成一个执行栈，执行栈可以实现函数的层层调用。")],-1),y=(0,e._)("p",null,[(0,e._)("strong",null,"异步任务"),(0,e.Uk)("：这个队列的所有任务都是不进入主线程执行，而是被浏览提供的线程执行，当执行完毕后就会产生一个回调函数，并且通知主线程，在主线程执行完当前所执行的任务后，就会调取最早通知自己的回调函数，使其进入主线程中执行，比如 ajax 请求，再主线程中呈现的就是请求结果。 "),(0,e._)("img",{src:s,alt:""})],-1),v=(0,e._)("ul",null,[(0,e._)("li",null,"所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。"),(0,e._)("li",null,'主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件（回调函数 callback）。'),(0,e._)("li",null,'一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。'),(0,e._)("li",null,"主线程不断重复上面的第三步。 “任务队列”是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。")],-1),x=(0,e._)("p",null,"“任务队列”中的事件，除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。",-1),j=(0,e._)("p",null,"所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。",-1),w=(0,e._)("p",null,[(0,e.Uk)("“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。因为存在"),(0,e._)("code",null,"setTimeout"),(0,e.Uk)("等定时函数，这类事件产生的消息进入到消息队列，被执行的时机取决与它在队列中的位置和执行时间有关。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。")],-1),E=(0,e._)("h2",{id:"v8-垃圾回收机制",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#v8-垃圾回收机制","aria-hidden":"true"},"#"),(0,e.Uk)(" V8 垃圾回收机制")],-1),A=(0,e.Uk)("参考链接 "),S={href:"https://mp.weixin.qq.com/s/VbAUPGt3sUVzEQHxWYmlBw",target:"_blank",rel:"noopener noreferrer"},J=(0,e.Uk)("13 张图！20 分钟！认识 V8 垃圾回收机制"),F=(0,e._)("h2",{id:"v8-引擎下的-数组-底层实现",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#v8-引擎下的-数组-底层实现","aria-hidden":"true"},"#"),(0,e.Uk)(" V8 引擎下的“数组”底层实现")],-1),H=(0,e._)("h3",{id:"背景",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#背景","aria-hidden":"true"},"#"),(0,e.Uk)(" 背景")],-1),I=(0,e._)("p",null,[(0,e.Uk)("C、C++、Java、Scala 等语言中数组的实现，是通过在内存中划分一串"),(0,e._)("strong",null,"连续的、固定长度"),(0,e.Uk)("的空间，来实现存放一组有限个"),(0,e._)("strong",null,"相同数据类型"),(0,e.Uk)("的数据结构。JS 的数组可以存放不同类型的元素、并且数组长度是可变的。")],-1),V=(0,e._)("h3",{id:"js-数组的实现",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#js-数组的实现","aria-hidden":"true"},"#"),(0,e.Uk)(" JS 数组的实现")],-1),B=(0,e._)("p",null,"在 JS 中数组被实现为特殊的对象，底层就是个 Map ，key 为 0，1，2，3 这种索引，value 就是数组的元素。",-1),C=(0,e._)("p",null,[(0,e.Uk)("V8 中对数组做了一层封装，使其有两种实现方式："),(0,e._)("strong",null,"快数组和慢数组"),(0,e.Uk)("，快数组底层是连续内存，通过索引直接定位，慢数组底层是哈希表，通过计算哈希值来定位。两种实现方式各有特点，有各自的使用情况，也会相互转换。")],-1),T=(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("p",null,"快数组：快速的后备存储结构是 FixedArray ，并且数组长度 <= elements.length();")]),(0,e._)("li",null,[(0,e._)("p",null,"慢数组：缓慢的后备存储结构是一个以数字为键的 HashTable 。")])],-1),q=(0,e._)("blockquote",null,[(0,e._)("p",null,"散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。")],-1),O=(0,e._)("h4",{id:"快数组-fast-elements",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#快数组-fast-elements","aria-hidden":"true"},"#"),(0,e.Uk)(" 快数组（FAST ELEMENTS）")],-1),z=(0,e._)("p",null,"新创建的空数组，默认的存储方式是快数组，快数组是一种线性的存储方式，长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现",-1),L=(0,e._)("p",null,[(0,e.Uk)("扩容的计算方式："),(0,e._)("code",null,"new_capacity = old_capacity /2 + old_capacity + 16"),(0,e.Uk)("，也就是，扩容后的新容量 = 旧容量的 1.5 倍 + 16，扩容后会将数组拷贝到新的内存空间中")],-1),M=(0,e._)("p",null,[(0,e.Uk)("收缩的计算方式：如果"),(0,e._)("code",null,"容量 >= length的2倍 + 16"),(0,e.Uk)("，则进行收缩容量调整，否则用 holes 对象填充未被初始化的位置。")],-1),N=(0,e._)("blockquote",null,[(0,e._)("p",null,"holes （空洞）对象指的是数组中分配了空间，但是没有存放元素的位置。")],-1),P=(0,e._)("p",null,[(0,e._)("strong",null,"Fast Elements 和 Fast Holey Elements")],-1),W=(0,e._)("p",null,"Fast Elements 模式中有一个扩展，是 Fast Holey Elements 模式，Fast Holey Elements 模式与 Fast Elements 模式一样，会动态分配连续的存储空间，分配空间的大小由最大的索引值决定。",-1),Y=(0,e._)("p",null,[(0,e.Uk)("新建数组时，如果没有设置容量，V8 会默认使用 Fast Elements 模式实现，如"),(0,e._)("code",null,"let a = new Array(1,2,3)")],-1),D=(0,e._)("p",null,[(0,e.Uk)("对数组设置容量，但并没有进行内部元素的初始化，这样的话数组内部就存在了空洞，就会以 Fast Holey Elements 模式实现。例如"),(0,e._)("code",null,"let a = new Array(10)"),(0,e.Uk)("。 Fast Holey Elements 模式适合于数组中的 holes （空洞）情况，即只有某些索引存有数据，而其他的索引都没有赋值的情况。")],-1),G=(0,e._)("h4",{id:"慢数组-dictionary-elements",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#慢数组-dictionary-elements","aria-hidden":"true"},"#"),(0,e.Uk)(" 慢数组（DICTIONARY ELEMENTS）")],-1),R=(0,e._)("p",null,[(0,e.Uk)("慢数组是一种字典的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，"),(0,e._)("strong",null,"其效率会比快数组低")],-1),K=(0,e._)("h3",{id:"快数组、慢数组的区别",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#快数组、慢数组的区别","aria-hidden":"true"},"#"),(0,e.Uk)(" 快数组、慢数组的区别")],-1),Q=(0,e._)("ul",null,[(0,e._)("li",null,"存储：快数组内存中是连续的，慢数组在内存中是零散分配的。"),(0,e._)("li",null,"内存：由于快数组内存是连续的，可能需要开辟一大块供其使用，其中还可能有很多空洞，是比较费内存的。慢数组不会有空洞的情况，且都是零散的内存，比较节省内存空间。"),(0,e._)("li",null,"遍历效率：快数组由于是空间连续的，遍历速度很快，而慢数组每次都要寻找 key 的位置，遍历效率会差一些。")],-1),X=(0,e._)("h3",{id:"快数组慢数组之间的转换",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#快数组慢数组之间的转换","aria-hidden":"true"},"#"),(0,e.Uk)(" 快数组慢数组之间的转换")],-1),Z=(0,e._)("h4",{id:"快-慢",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#快-慢","aria-hidden":"true"},"#"),(0,e.Uk)(" 快 -> 慢")],-1),$=(0,e._)("p",null,"当出现以下情况时快数组会转换为慢数组",-1),nn=(0,e._)("ul",null,[(0,e._)("li",null,"新容量 >= 3 _ 扩容后的容量 _ 2"),(0,e._)("li",null,"当加入的 index- 当前 capacity >= kMaxGap（1024） 时（也就是至少有了 1024 个空洞）")],-1),an=(0,e._)("div",{class:"language-javascript ext-js line-numbers-mode"},[(0,e._)("pre",{class:"language-javascript"},[(0,e._)("code",null,[(0,e._)("span",{class:"token comment"},"// 第二种情况示例"),(0,e.Uk)("\n"),(0,e._)("span",{class:"token keyword"},"let"),(0,e.Uk)(" a "),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token punctuation"},"["),(0,e._)("span",{class:"token number"},"1"),(0,e._)("span",{class:"token punctuation"},","),(0,e.Uk)(),(0,e._)("span",{class:"token number"},"2"),(0,e._)("span",{class:"token punctuation"},"]"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\na"),(0,e._)("span",{class:"token punctuation"},"["),(0,e._)("span",{class:"token number"},"1030"),(0,e._)("span",{class:"token punctuation"},"]"),(0,e.Uk)(),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token number"},"1"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\n")])]),(0,e._)("div",{class:"line-numbers"},[(0,e._)("span",{class:"line-number"},"1"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"2"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"3"),(0,e._)("br")])],-1),ln=(0,e._)("h4",{id:"慢-快",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#慢-快","aria-hidden":"true"},"#"),(0,e.Uk)(" 慢 -> 快")],-1),en=(0,e._)("p",null,"处于哈希表实现的数组，在每次空间增长时， V8 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。",-1),sn=(0,e._)("p",null,[(0,e.Uk)("当慢数组的元素可存放在快数组中且长度在 smi（smi 在 64 位平台为-2^31 到 2^31 -1,32 位平台为-2^30 到 2^30 - 1） 之间且仅节省了 50%的空间（"),(0,e._)("code",null,"2*dictionary_size>=new_capacity"),(0,e.Uk)("）,则会转变为快数组")],-1),tn=(0,e._)("p",null,"现在往数组中添加值来填补空洞，往 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，数组会变成快数组的 Fast Holey Elements 模式",-1),rn=(0,e._)("div",{class:"language-javascript ext-js line-numbers-mode"},[(0,e._)("pre",{class:"language-javascript"},[(0,e._)("code",null,[(0,e._)("span",{class:"token keyword"},"let"),(0,e.Uk)(" a "),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token punctuation"},"["),(0,e._)("span",{class:"token number"},"1"),(0,e._)("span",{class:"token punctuation"},","),(0,e.Uk)(),(0,e._)("span",{class:"token number"},"2"),(0,e._)("span",{class:"token punctuation"},"]"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\na"),(0,e._)("span",{class:"token punctuation"},"["),(0,e._)("span",{class:"token number"},"1030"),(0,e._)("span",{class:"token punctuation"},"]"),(0,e.Uk)(),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token number"},"1"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\n"),(0,e._)("span",{class:"token keyword"},"for"),(0,e.Uk)(),(0,e._)("span",{class:"token punctuation"},"("),(0,e._)("span",{class:"token keyword"},"let"),(0,e.Uk)(" i "),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token number"},"200"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)(" i "),(0,e._)("span",{class:"token operator"},"<"),(0,e.Uk)(),(0,e._)("span",{class:"token number"},"1030"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)(" i"),(0,e._)("span",{class:"token operator"},"++"),(0,e._)("span",{class:"token punctuation"},")"),(0,e.Uk)(),(0,e._)("span",{class:"token punctuation"},"{"),(0,e.Uk)("\n  a"),(0,e._)("span",{class:"token punctuation"},"["),(0,e.Uk)("i"),(0,e._)("span",{class:"token punctuation"},"]"),(0,e.Uk)(),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(" i"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\n"),(0,e._)("span",{class:"token punctuation"},"}"),(0,e.Uk)("\n")])]),(0,e._)("div",{class:"line-numbers"},[(0,e._)("span",{class:"line-number"},"1"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"2"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"3"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"4"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"5"),(0,e._)("br")])],-1),un=(0,e._)("ul",null,[(0,e._)("li",null,"快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。"),(0,e._)("li",null,"慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。")],-1),_n=(0,e._)("h3",{id:"arraybuffer",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#arraybuffer","aria-hidden":"true"},"#"),(0,e.Uk)(" ArrayBuffer")],-1),cn=(0,e._)("p",null,"JS 在 ES6 也推出了可以按照需要分配连续内存的数组，这就是 ArrayBuffer。ArrayBuffer 会从内存中申请设定的二进制大小的空间",-1),on=(0,e._)("div",{class:"language-javascript ext-js line-numbers-mode"},[(0,e._)("pre",{class:"language-javascript"},[(0,e._)("code",null,[(0,e._)("span",{class:"token keyword"},"let"),(0,e.Uk)(" buffer "),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token keyword"},"new"),(0,e.Uk)(),(0,e._)("span",{class:"token class-name"},"ArrayBuffer"),(0,e._)("span",{class:"token punctuation"},"("),(0,e._)("span",{class:"token number"},"1024"),(0,e._)("span",{class:"token punctuation"},")"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\n")])]),(0,e._)("div",{class:"line-numbers"},[(0,e._)("span",{class:"line-number"},"1"),(0,e._)("br")])],-1),pn=(0,e._)("p",null,"这行代码就申请了 1kb 的内存区域。但是并不能对 arrayBuffer 直接操作，需要将它赋给一个视图来操作内存。",-1),kn=(0,e._)("div",{class:"language-javascript ext-js line-numbers-mode"},[(0,e._)("pre",{class:"language-javascript"},[(0,e._)("code",null,[(0,e._)("span",{class:"token keyword"},"let"),(0,e.Uk)(" buffer "),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token keyword"},"new"),(0,e.Uk)(),(0,e._)("span",{class:"token class-name"},"ArrayBuffer"),(0,e._)("span",{class:"token punctuation"},"("),(0,e._)("span",{class:"token number"},"1024"),(0,e._)("span",{class:"token punctuation"},")"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\n\n"),(0,e._)("span",{class:"token comment"},"// 创建了有符号的32位的整数数组，每个数占 4 字节，长度也就是 1024 / 4 = 256 个"),(0,e.Uk)("\n"),(0,e._)("span",{class:"token keyword"},"let"),(0,e.Uk)(" intArray "),(0,e._)("span",{class:"token operator"},"="),(0,e.Uk)(),(0,e._)("span",{class:"token keyword"},"new"),(0,e.Uk)(),(0,e._)("span",{class:"token class-name"},"Int32Array"),(0,e._)("span",{class:"token punctuation"},"("),(0,e.Uk)("buffer"),(0,e._)("span",{class:"token punctuation"},")"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\nconsole"),(0,e._)("span",{class:"token punctuation"},"."),(0,e._)("span",{class:"token function"},"log"),(0,e._)("span",{class:"token punctuation"},"("),(0,e.Uk)("intArray"),(0,e._)("span",{class:"token punctuation"},")"),(0,e._)("span",{class:"token punctuation"},";"),(0,e.Uk)("\n"),(0,e._)("span",{class:"token comment"},"// Int32Array(256)[0,0,0,0,0,0,...]"),(0,e.Uk)("\n")])]),(0,e._)("div",{class:"line-numbers"},[(0,e._)("span",{class:"line-number"},"1"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"2"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"3"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"4"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"5"),(0,e._)("br"),(0,e._)("span",{class:"line-number"},"6"),(0,e._)("br")])],-1),dn=(0,e.Uk)("参考链接： "),hn={href:"https://zhuanlan.zhihu.com/p/96959371",target:"_blank",rel:"noopener noreferrer"},Un=(0,e.Uk)("探究 JS V8 引擎下的“数组”底层实现"),bn={render:function(n,a){const l=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,r,u,_,c,o,i,p,k,d,h,U,b,m,f,g,y,v,x,j,w,E,(0,e._)("blockquote",null,[(0,e._)("p",null,[A,(0,e._)("a",S,[J,(0,e.Wm)(l)])])]),F,H,I,V,B,C,T,q,O,z,L,M,N,P,W,Y,D,G,R,K,Q,X,Z,$,nn,an,ln,en,sn,tn,rn,un,_n,cn,on,pn,kn,(0,e._)("blockquote",null,[(0,e._)("p",null,[dn,(0,e._)("a",hn,[Un,(0,e.Wm)(l)])])])],64)}}},6862:(n,a,l)=>{n.exports=l.p+"assets/img/任务队列.5e94b710.png"}}]);