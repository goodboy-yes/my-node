"use strict";(self.webpackChunkmy_notes=self.webpackChunkmy_notes||[]).push([[594],{5509:(e,t,o)=>{o.r(t),o.d(t,{data:()=>r});const r={key:"v-400d76ab",path:"/git/reset-and-revert.html",title:"git reset 和 git revert 的区别",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"git reset",slug:"git-reset",children:[]},{level:2,title:"git revert",slug:"git-revert",children:[]},{level:2,title:"区别",slug:"区别",children:[]}],filePathRelative:"git/reset-and-revert.md",git:{updatedTime:1629713165e3,contributors:[]}}},196:(e,t,o)=>{o.r(t),o.d(t,{default:()=>i});var r=o(6252);const c=(0,r.uE)('<h1 id="git-reset-和-git-revert-的区别" tabindex="-1"><a class="header-anchor" href="#git-reset-和-git-revert-的区别" aria-hidden="true">#</a> git reset 和 git revert 的区别</h1><h2 id="git-reset" tabindex="-1"><a class="header-anchor" href="#git-reset" aria-hidden="true">#</a> git reset</h2><p><code>reset</code>用于回退版本，有三种模式，<code>soft</code>,<code>mixed</code>,<code>hard</code><img src="https://upload-images.jianshu.io/upload_images/4428238-fcad08ebe26933a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp" alt=""></p><p><strong>reset --hard：重置 stage 区和工作目录</strong></p><p><code>reset --hard</code> 会在重置 <code>HEAD</code> 和<code>branch</code>的同时，重置<code>stage</code>区和工作目录里的内容。当你在 reset 后面加了 <code>--hard</code> 参数时，你的 <code>stage</code> 区和工作目录里的内容会被完全重置为和 <code>HEAD</code> 的新位置相同的内容。换句话说，就是你的没有 <code>commit</code> 的修改会被全部擦掉。</p><p><strong>reset --soft：保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区</strong></p><p><code>reset --soft</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 时，保留工作目录和暂存区中的内容，并把重置 <code>HEAD</code> 所带来的新的差异放进暂存区。</p><p><strong>reset 不加参数(mixed)：保留工作目录，并清空暂存区</strong></p><p><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code> 参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 <code>reset</code> 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（<code>mixed</code>）放在工作目录中」。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> reset --<span class="token operator">&lt;</span>参数<span class="token operator">&gt;</span> HEAD^ //回退到上一个提交\n<span class="token function">git</span> reset --<span class="token operator">&lt;</span>参数<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span> //回退到指定提交\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>总结</strong></p><p>实质上，<code>reset</code> 这个指令虽然可以用来撤销 <code>commit</code> ，但它的实质行为并不是撤销，而是移动 <code>HEAD</code> ，并且「捎带」上 <code>HEAD</code> 所指向的 <code>branch</code>（如果有的话）。</p><p>而<code>reset --hard HEAD^</code>之所以起到了撤销 <code>commit</code> 的效果，是因为它把 <code>HEAD</code> 和它所指向的 <code>branch</code> 一起移动到了当前 <code>commit</code> 的父 <code>commit</code> 上，从而起到了「撤销」的效果：</p><p><strong>使用场景</strong></p><ul><li><strong>--hard</strong>：要放弃目前本地的所有改变,抛弃目标节点后的所有 commit</li><li><strong>--soft</strong>：想合并「当前节点」与「reset 目标节点」之间不具太大意义的 commit 记录，假如你需要把频繁提交的 commit 整合成一个 commit 的时候</li><li><strong>--mixed（默认）</strong>：与--soft 类似，再次提交多了 git add 添加到暂存区的操作</li></ul><h2 id="git-revert" tabindex="-1"><a class="header-anchor" href="#git-revert" aria-hidden="true">#</a> git revert</h2><p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> revert <span class="token operator">&lt;</span>commit_id<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h2><ul><li><code>git revert</code> 是用一次新的 <code>commit</code> 来回滚之前的 <code>commit</code>，<code>git reset</code> 是直接删除指定的 <code>commit</code></li><li><code>git reset</code> 是把 <code>HEAD</code> 向后移动了一下，而 <code>git revert</code> 是 <code>HEAD</code> 继续前进，只是新的 <code>commit</code> 的内容和要 <code>revert</code> 的内容正好相反，能够抵消要被 <code>revert</code> 的内容</li><li>在回滚这一操作上看，效果差不多。<strong>但是在日后继续 merge 以前的老版本时有区别</strong><ul><li><code>git revert</code> 是用一次逆向的 <code>commit</code>“中和”之前的提交，因此日后合并老的 <code>branch</code> 时，之前提交合并的代码仍然存在，导致不能够重新合并</li><li><code>git reset</code> 是之间把某些 <code>commit</code> 在某个 <code>branch</code> 上删除，因而和老的 <code>branch</code> 再次 <code>merge</code> 时，这些被回滚的 <code>commit</code> 应该还会被引入</li></ul></li></ul><p><strong>参考文章：</strong></p>',21),d={href:"https://www.jianshu.com/p/c2ec5f06cf1a",target:"_blank",rel:"noopener noreferrer"},s=(0,r.Uk)("Git Reset 三种模式"),a={href:"https://mp.weixin.qq.com/s/Z3kLQz67omQdT8GA5LsC7g",target:"_blank",rel:"noopener noreferrer"},n=(0,r.Uk)("面试官：说说你对 git reset 和 git revert 的理解？区别？"),i={render:function(e,t){const o=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.iD)(r.HY,null,[c,(0,r._)("p",null,[(0,r._)("a",d,[s,(0,r.Wm)(o)])]),(0,r._)("p",null,[(0,r._)("a",a,[n,(0,r.Wm)(o)])])],64)}}}}]);