"use strict";(self.webpackChunkmy_notes=self.webpackChunkmy_notes||[]).push([[305],{2401:(e,s,n)=>{n.r(s),n.d(s,{data:()=>a});const a={key:"v-5aa6f003",path:"/js/regular-expression.html",title:"正则表达式",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"构造正则表达式",slug:"构造正则表达式",children:[]},{level:2,title:"修饰符",slug:"修饰符",children:[]},{level:2,title:"元字符",slug:"元字符",children:[]},{level:2,title:"反向应用",slug:"反向应用",children:[]},{level:2,title:"正则匹配举例",slug:"正则匹配举例",children:[]},{level:2,title:"正则表达式的使用",slug:"正则表达式的使用",children:[]}],filePathRelative:"js/regular-expression.md",git:{updatedTime:162999496e4,contributors:[]}}},3336:(e,s,n)=>{n.r(s),n.d(s,{default:()=>o});const a=(0,n(6252).uE)('<h1 id="正则表达式" tabindex="-1"><a class="header-anchor" href="#正则表达式" aria-hidden="true">#</a> 正则表达式</h1><h2 id="构造正则表达式" tabindex="-1"><a class="header-anchor" href="#构造正则表达式" aria-hidden="true">#</a> 构造正则表达式</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//通过字面常量的方式，一对正斜杠中间写表达式内容,后面可以跟修饰符。</span>\n<span class="token keyword">const</span> ex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[abcd]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">;</span>\n\n<span class="token comment">//通过构造函数的方式，第一个参数是表达式内容，第二个参数是修饰符</span>\n<span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;[abcd]&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;gi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="修饰符" tabindex="-1"><a class="header-anchor" href="#修饰符" aria-hidden="true">#</a> 修饰符</h2><ul><li><code>i</code> 执行大小写不敏感的匹配</li><li><code>g</code>执行全局匹配，即返回所有匹配的子串，默认只返回第一个匹配</li><li><code>m</code>多行匹配，^ 和 $ 在字符串的每一行都进行一次匹配。</li><li><code>s</code>使特殊字符圆点 <code>.</code>中包含换行符 <code>\\n</code></li></ul><h2 id="元字符" tabindex="-1"><a class="header-anchor" href="#元字符" aria-hidden="true">#</a> 元字符</h2><ul><li><p><code>\\</code> 在字面意义和特殊意义之间进行转换，例如/表示字符/。</p></li><li><p><code>^</code> 匹配字符串的开头</p></li><li><p><code>$</code> 匹配字符串的结尾</p></li><li><p><code>()</code> 小括号里面的元素结合为一组，可以在后面引用它</p></li><li><p><code>[]</code> 匹配字符集中的一个字符，例如<code>[abc]</code>表示匹配字符 a 或 b 或 c；[^abc]表示匹配不等于 a 或 b 或 c 的字符；<code>[a-e]</code>匹配在 a 到 e 范围内的字符；<code>[a-b0-9A-Z_]</code>匹配字母数字和下划线。</p></li><li><p><code>|</code> 或操作，例如(jpg|png)表示匹配字符串 jpg 或字符串 png。</p></li><li><p><code>{}</code> 表示前面的字符应该出现的次数。<code>{n}</code>表示出现 n 次;<code>{n,}</code>表示至少出现 n 次；<code>{n,m}</code>表示出现 n 次到 m 次。</p></li><li><p><code>*</code> 匹配前面的子表达式零次或多次。例如，<code>zo*</code> 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。 * 等价于<code>{0,}</code>。</p></li><li><p><code>+</code> 匹配前面的子表达式一次或多次。例如，<code>zo+</code> 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 <code>{1,}</code>。</p></li><li><p><code>?</code> 匹配前面的子表达式零次或一次。例如，<code>do(es)?</code> 可以匹配 &quot;do&quot; 或 &quot;does&quot; 中的&quot;do&quot; 。? 等价于 <code>{0,1}</code>。</p></li><li><p><code>\\f</code> 匹配一个换页符。等价于 <code>\\x0c</code> 和 <code>\\cL</code>。</p></li><li><p><code>\\n</code> 匹配一个换行符。等价于 <code>\\x0a</code> 和 <code>\\cJ</code>。</p></li><li><p><code>\\r</code> 匹配一个回车符。等价于 <code>\\x0d</code> 和 <code>\\cM</code>。</p></li><li><p><code>\\t</code> 匹配一个制表符。等价于<code>\\x09</code> 和 <code>\\cI</code>。</p></li><li><p><code>\\v</code> 匹配一个垂直制表符。等价于 <code>\\x0b</code> 和 <code>\\cK</code>。</p></li><li><p><code>.</code> 匹配除换行符 \\n 之外的任何单字符。</p></li><li><p><code>\\d</code> 匹配数字<code>[0-9]</code></p></li><li><p><code>\\D</code> 匹配非数字字符<code>[^0-9]</code></p></li><li><p><code>\\s</code> 匹配一个空白字符<code>[\\f\\n\\r\\t\\v]</code></p></li><li><p><code>\\S</code> 匹配一个非空白字符<code>[^\\f\\n\\r\\t\\v]</code></p></li><li><p><code>\\w</code> 匹配字母数字和下划线<code>[a-zA-Z0-9_]</code></p></li><li><p><code>\\W</code> 匹配除字母数字下划线之外的字符<code>[^a-za-z0-9_] </code></p></li><li><p><code>\\b</code>匹配一个零宽单词边界</p></li><li><p><code>\\B</code> 匹配一个零宽非单词边界</p><p>零宽: 只匹配位置, 不匹配字符</p><p>单词： 在 JS 中, 单词的定义就是<code>\\w</code>, 非单词的定义就是<code>\\W</code>, 非常简洁</p><p>边界：也就是在这个位置之前是单词, 那么在这个位置之后就是非单词, 反之也是这样。例如:</p><p><img src="https://pic2.zhimg.com/50/v2-46442794009ec26d73a388519b9cab86_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-46442794009ec26d73a388519b9cab86_720w.jpg?source=1940ef5c" alt="img"></p><p>从上图可以看到, 在开头和结尾各有一个单词边界, 因为开头处, 边界的右端是单词, 而左端不是, 二者不同, 所以就有一个单词界限.</p><p>在 <code>My</code> 的结尾处也有一处界限, 因为在界限的左端是单词 <code>y</code>, 右端是空格, 二者不同, 所以是界限.</p><p>何谓非边界? 同类无界. <code>\\w\\w</code> 或者 <code>\\W\\W</code>, 这个位置前后都是同类, 所以就没有界这一说.</p><p><img src="https://pic2.zhimg.com/50/v2-e6c9037e18c8dee5b1228831d818fd3c_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/v2-e6c9037e18c8dee5b1228831d818fd3c_720w.jpg?source=1940ef5c" alt="img"></p><p>单词和单词是同类, 之间无界限, 所以我们可以看到每个字母之间都是非界限.</p><p>在 <code>cat</code> 后面有两个空格, 两个非单词也是同类, 所以中间有一个非界限.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ter\\b</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">// 匹配单词 Chapter 中的字符串 ter</span>\n<span class="token operator">/</span>\\Bapt<span class="token operator">/</span><span class="token punctuation">;</span> <span class="token comment">// 匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p><code>(?:pattern) </code>非获取匹配，匹配 &#39;pattern&#39; 但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“<code>industr(?:y|ies)</code>”就是一个比“<code>industry|industries</code>”更简略的表达式。</p></li><li><p><code>(?=pattern)</code>非获取匹配，正向肯定预查，在任何匹配 &#39;pattern&#39;的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“<code>Windows(?=95|98|NT|2000)</code>”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p></li><li><p><code> (?!pattern)</code>非获取匹配，正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“<code>Windows(?!95|98|NT|2000)</code>”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</p></li><li><p><code>(?&lt;=pattern)</code>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“<code>(?&lt;=95|98|NT|2000)Windows</code>”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</p></li><li><p><code>(?&lt;!pattern)</code>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“<code>(?&lt;!95|98|NT|2000)Windows</code>”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</p></li></ul><p>大部分元字符与自己最近的元素或组相结合，除了<code>|</code>字符与它所在的组内的前后所有元素相结合。</p><p>默认情况下对于出现次数的匹配都采用<strong>贪婪匹配</strong>的方式，即尽可能地多匹配。例如用<code>/a+/</code>匹配字符串&quot;aaaaaa&quot;,将匹配&quot;aaaaaa&quot;而不是&quot;a&quot;。 在次数匹配字符后面加<code>?</code>可将贪婪匹配改为<strong>谨慎匹配</strong>，例如<code>/a+?/</code>匹配字符串&quot;aaaaaa&quot;,将匹配&quot;a&quot;。</p><p>若要匹配一行文本开始处的文本，请在正则表达式的开始使用<code>^</code> 字符。不要将 <code>^</code> 的这种用法与中括号表达式内的用法混淆</p><h2 id="反向应用" tabindex="-1"><a class="header-anchor" href="#反向应用" aria-hidden="true">#</a> 反向应用</h2><p>一个正则表达式中括号内的模式会存储到一个临时缓冲区中，缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <code>\\n</code> 访问</p><p>可以使用非捕获元字符 <code>?:</code>、<code>?=</code> 或 <code>?!</code> 来重写捕获，忽略对相关匹配的保存。</p><p>如<code>/\\b([a-z]+) \\1\\b/ig</code>匹配重复的单词，<code>\\1</code> 指定第一个子匹配项，单词边界元字符确保只检测整个单词。否则，诸如 &quot;<code>is issued</code>&quot; 或 &quot;<code>this is</code>&quot; 之类的词组将不能正确地被此表达式识别。</p><h2 id="正则匹配举例" tabindex="-1"><a class="header-anchor" href="#正则匹配举例" aria-hidden="true">#</a> 正则匹配举例</h2><p><strong>验证电子邮件</strong>：<code>/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/</code></p><ol><li>以<code>\\w</code>起头，随后可以包含任意数量的“.”或“-”只要他们之间有一个或多个\\w 分隔即可（对应于域名检测）；</li><li>用户名之后带一个@字符；</li><li>以\\w 起头，随后可以包含任意数量的“.”或“-”只要他们之间有一个或多个\\w 分隔即可（对应于邮箱地址检测）；</li><li>以“.”加上 2 到 3 个“\\w”结尾。(对应于邮箱地址后缀的检测例如“.com”,“.cn”等)。</li></ol><p><strong>验证文件路径</strong>：<code>/^(http|https|file):\\/\\/\\S+\\/\\S+/i</code></p><ol><li>文件路径使用 http 或 https 或 file 开头，后跟://</li><li>然后是任意个非空字符表示的文件路径</li><li>最后是/加上任意非空字符表示的文件名</li><li>修饰符 i 忽略大小写</li></ol><h2 id="正则表达式的使用" tabindex="-1"><a class="header-anchor" href="#正则表达式的使用" aria-hidden="true">#</a> 正则表达式的使用</h2><p><strong>RegExp 类：</strong></p><p><code>RegExp.source</code> 返回正则表达式的内容</p><p><code>RegExp.test(s)</code> 测试字符串 s 是否与正则表达式项匹配</p><p><code>RegExp.exec(s)</code> 匹配字符串 s，返回匹配到的子串和各个组匹配到的子串的数组，若没有匹配到任何子串则返回 null</p><p><code>RegExp.lastIndex</code> 返回最近一次匹配到的位置。默认值为-1，用于标记由方法 <strong>RegExp.exec()</strong> 和 <strong>RegExp.test()</strong> 找到的结果的下次检索的起始点。只有正则表达式使用了表示全局检索的 &quot;<code>g</code>&quot; 标志时，该属性才会起作用</p><p><strong>String 类</strong></p><p><code>String.search(re)</code> 返回 re 匹配到的第一个位置，若不匹配则返回-1。</p><p><code>String.match(re)</code> 返回 re 匹配到的所有子串的数组，若不匹配返回 null。</p><p><code>String.split(re)</code> 用正则表达式匹配到的所有子串来将字符串分割为字符串数组。</p><p><code>String.replace(re, s)</code> 将 re 匹配到的字符替换为 s。(replace 方法的第二个参数也可以是函数)</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\w</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span>\nreg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;js&#39;</span><span class="token punctuation">)</span> <span class="token comment">//true</span>\nreg<span class="token punctuation">.</span>lastIndex <span class="token comment">//1</span>\nreg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;js&#39;</span><span class="token punctuation">)</span> <span class="token comment">//true</span>\nreg<span class="token punctuation">.</span>lastIndex <span class="token comment">//2</span>\nreg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;js&#39;</span><span class="token punctuation">)</span> <span class="token comment">//false</span>\nreg<span class="token punctuation">.</span>lastIndex <span class="token comment">//0 匹配失败后清零</span>\n\n<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">&quot;hello123back, hello456back&quot;</span><span class="token punctuation">;</span>\n<span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(hello).*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment">// true</span>\n<span class="token operator">/</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment">// [&#39;hello123back, hello456back&#39;,&#39;hello&#39;]</span>\n\nstr<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(hello).*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>\nstr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(hello).*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&#39;hello123back, hello456back&#39;,&#39;hello&#39;]</span>\nstr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?:hello).*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&#39;hello123back, hello456back&#39;]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div>',31),o={render:function(e,s){return a}}}}]);